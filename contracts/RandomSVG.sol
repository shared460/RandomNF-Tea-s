//SPDX_License_Identifier: MIT

pragma solidity^ 0.8.19;

import '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';
import '@chainlink/contracts/src/v0.8/vrf/VRFConsumerBase.sol';
import 'base64-sol/base64.sol';


import 'hardhat/console.sol';


contract RandomSVG is ERC721URIStorage, VRFConsumerBase{

    bytes32 public keyHash;
    uint256 fee;
    mapping(bytes32 => address) public requestIdToSender;
    mapping(bytes32 => uint256) public requestIdToTokenId;
    mapping(uint256 => uint256) public requestTokenIdToRandomNo;

    //SVG parameters
    uint256 public maxNumberOfPaths;
    uint256 public maxNumberOfPathsCommands;
    uint256 public size;                        //fixed
    string[] public pathCommands;               //depends on random number
    string[] public colors;                     //depends on random number


    uint256 tokenCounter;

    //index a parameter in an evebt just means it is top
    event requestRandomSVG(bytes32 indexed _requestId, uint256 indexed _tokenId);
    event randomNumberWithTokenId(uint256 indexed _tokenId, uint256 indexed _randomNumber);
    event createRandomSVG(uint256 indexed _tokenId, string svg);

    
    //this VRFCoordinator address will be generated by our given network address
    constructor(address _VRFCoordinatorAddress, address _linkToken, bytes32 _keyHash, uint256 _fee) ERC721('RandomSVG','rSVG') VRFConsumerBase(_VRFCoordinatorAddress, _linkToken){
        keyHash = _keyHash;
        fee = _fee;
        tokenCounter = 0;
        maxNumberOfPaths = 10;
        maxNumberOfPathsCommands = 5;
        size = 500;
        pathCommands = ["M", "L"];
        colors = ['red','blue','green','purple','black','yellow'];
    }
    

    //creating radnom nft
    function create(bytes32 _keyHash, uint256 _fee) public returns(bytes32 requestId){
        //in returning by name same as intlization

        requestId = requestRandomness(_keyHash, _fee);

        requestIdToSender[requestId] = msg.sender;
        uint256 tokenId = tokenCounter;
        requestIdToTokenId[requestId] = tokenId;
        tokenCounter = tokenCounter + 1;

        emit requestRandomSVG(requestId, tokenId);


        //1. get a random number
        //2. use random number to generate random svg code
        //3. base64 encode the svg code
        //4. get the tokenURI and mint the NFT
        // here we can't do math.random()
        // here we can do keaack(block.diificulty,..)   it is hackable
        //7. oracles, chainlink VRF(chainlink veriable randomness function.abi
    }

    //no other can call this function
    function fulfillRandomness(bytes32 _requestId, uint256 _randomNumber) internal override{
        address nftOwner = requestIdToSender[_requestId];
        uint256 tokenId = requestIdToTokenId[_requestId];
        
        _safeMint(nftOwner, tokenId);

        requestTokenIdToRandomNo[tokenId] = _randomNumber;
        emit randomNumberWithTokenId(tokenId, _randomNumber);
        

    }

    function finishMint(uint256 _tokenId) public{
        //check to see if its been minted and random number is generated
        //generate some random svg code
        //turn taht into an mage uri
        //use image uri into an token uri

        require(bytes(tokenURI(_tokenId)).length <= 0,'tokenURI is all set...');
        require(tokenCounter > _tokenId, "tokenId has not been minted yet!");
        require(requestTokenIdToRandomNo[_tokenId] > 0,'random number is not get from chainlink VRF...');

        uint256 randomNumber = requestTokenIdToRandomNo[_tokenId];
        console.log('random number generated by vrf chainlink ... ',randomNumber);

        console.log('time to set up the metadat of an NFT');

        string memory svg = generateSVG(randomNumber);
        string memory imageURI = generateImageURI(svg);
        string memory T_tokenURI = generateTokenURI(imageURI);
        _setTokenURI(_tokenId, T_tokenURI);

        console.log('NFT is minted....');
        emit createRandomSVG(_tokenId, svg);
    }








    /**
        @dev only generating svg with less then max paths by concating and values to the string, loop of for number of 
        paths include in an svg
    */
    function generateSVG(uint256 _randomNumber) internal view returns(string memory finalSVG){
        //how we can generate random svg

        uint256 numberOfPaths = _randomNumber%maxNumberOfPaths + 1;
        finalSVG = string(abi.encodePacked("<svg xmlns='https://www.w3schools.com/2000/svg' height=",uint2str(size),"width=",uint2str(size),">"));
        
        for(uint i=0;i<numberOfPaths;i++){
            //here we are hashing the i with _randomNumber
            uint256 newRNG = uint256(keccak256(abi.encode(_randomNumber, i)));
            console.log('hashed generated number...',newRNG);

            string memory pathSVG = generatePath(newRNG);
            //concating many string 
            finalSVG = string(abi.encodePacked(finalSVG, pathSVG));
        }

        //adding closing tag
        finalSVG = string(abi.encodePacked(finalSVG, '</svg>'));
    }

    /**
        @dev generating the whole path which includes their tags and values random,
        it will gives us the single path
    */
    function generatePath(uint256 _newRNG) internal view returns(string memory pathSVG){
        
        uint256 numberOfPaths = _newRNG % maxNumberOfPathsCommands + 1;
        pathSVG = "<path d=";
        for(uint i=0; i<numberOfPaths; i++){
            uint256 newRNG = uint256(keccak256(abi.encodePacked(size+i, _newRNG)));
            console.log('hashed generated number...',newRNG);

            string memory pathCommands = generatePathCommands(newRNG);
            pathSVG = string(abi.encodePacked(pathSVG, pathCommands));
        }
        
        string memory color = colors[_newRNG % colors.length];

        pathSVG = string(abi.encodePacked(pathSVG, string(abi.encodePacked("fill='transparent' troke=",color,">"))));
    }

    /**
        @dev genrating the values for the path as randomly by varying x and y coordinate
    */
    function generatePathCommands(uint256 _newRNG) internal view returns(string memory pathSVG){
        
        pathSVG = pathCommands[_newRNG % pathCommands.length];
        uint256 parameterOne = uint256(keccak256(abi.encodePacked(_newRNG, size*2))) % size;
        uint256 parameterTwo = uint256(keccak256(abi.encodePacked(_newRNG, size*3))) % size;

        pathSVG = string(abi.encodePacked(pathSVG," ",uint2str(parameterOne)," ",uint2str(parameterTwo)));   

    }






    /**
        @dev by providing an svg we convert it into an imageURI as used for tokenURI
    */
    function generateImageURI(string memory _svg) internal pure returns(string memory imageURI){
        
        string memory baseURL = 'data:image/svg+xml;base64,';  
        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(_svg))));
        imageURI = string(abi.encodePacked(baseURL, svgBase64Encoded));

    }

    function generateTokenURI(string memory _imageURI) internal pure returns(string memory tokenURI){

        string memory baseURL = 'data:application/json;base64,';
        string memory json = Base64.encode(bytes(abi.encodePacked(
            '{"name": "NFTDROP"',
            ',"description": "An NFT based on SVG!"',
            ',"attributes": ""',
            ',"image":"',_imageURI, '"}')));
        tokenURI = string(abi.encodePacked(baseURL, json));
    }






    /**
        utility function
        @dev taking from stackoverflow as wants to convert from uint to string in solidity for abi.encodePacked(arg); as
        it takes strings only
    */
    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {
        if (_i == 0) {
            return "0";
        }
        uint j = _i;
        uint len;
        while (j != 0) {
            len++;
            j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len;
        while (_i != 0) {
            k = k-1;
            uint8 temp = (48 + uint8(_i - _i / 10 * 10));
            bytes1 b1 = bytes1(temp);
            bstr[k] = b1;
            _i /= 10;
        }
        return string(bstr);
    }

}